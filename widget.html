<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAYMON Metrics Widget</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: transparent;
            overflow: hidden;
        }
        .widget-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        .chart-container {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }
        .chart {
            width: 100%;
            height: calc(100% - 40px);
            border-radius: 6px;
            overflow: visible;
        }
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #666;
            font-size: 16px;
        }
        .error {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #e53e3e;
            font-size: 14px;
            text-align: center;
            padding: 20px;
        }
        .axis path, .axis line { stroke: #cbd5e0; }
        .axis text { fill: #4a5568; font-size: 11px; }
        .grid line { stroke: #e2e8f0; stroke-opacity: 0.7; }
        .grid path { stroke-width: 0; }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
        }
        .legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 12px;
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 10px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            color: #4a5568;
            white-space: nowrap;
        }
        .legend-color {
            width: 8px;
            height: 8px;
            border-radius: 2px;
        }
        .chart-title-bottom {
            font-weight: bold;
            color: #2d3748;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="widget-container">
        <div class="chart-container">
            <div id="chart" class="chart">
                <div class="loading">Loading chart...</div>
            </div>
            <div class="tooltip" id="tooltip"></div>
            <div class="legend" id="legend"></div>
        </div>
    </div>

    <script>
        class SaymonWidget {
            constructor() {
                this.data = [];
                this.margin = { top: 10, right: 80, bottom: 40, left: 50 };
                this.color = d3.scaleOrdinal(d3.schemeCategory10);
                this.strokeWidth = 2;
                this.pointSize = 4;
                this.reloadInterval = null;
                
                this.init();
            }

            init() {
                // Parse URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                
                // Check if period is specified
                const period = urlParams.get('period');
                
                if (period) {
                    // Calculate time range and downsample based on period
                    const { fromTimestamp, toTimestamp, downsample } = this.calculateTimeRange(period);
                    
                    this.config = {
                        objectId: urlParams.get('objectId') || '67cb1f1f120ab073c5adb8a2',
                        fromTimestamp: fromTimestamp,
                        toTimestamp: toTimestamp,
                        downsample: downsample,
                        metrics: urlParams.get('metrics') || 'ifHCInOctets,ifHCOutOctets',
                        authToken: urlParams.get('authToken'), // Optional - no default
                        chartType: urlParams.get('chartType') || 'line',
                        dataType: urlParams.get('dataType') || 'diff', // Rate (diff) or raw counter
                        width: parseInt(urlParams.get('width')) || window.innerWidth,
                        height: parseInt(urlParams.get('height')) || window.innerHeight,
                        period: period,
                        name: urlParams.get('name') // Optional custom chart name
                    };
                } else {
                    // Use explicit from/to/downsample if period not specified
                    this.config = {
                        objectId: urlParams.get('objectId') || '67cb1f1f120ab073c5adb8a2',
                        fromTimestamp: urlParams.get('from') || '1756497678991',
                        toTimestamp: urlParams.get('to') || '1756592718991',
                        downsample: urlParams.get('downsample') || '5m-avg',
                        metrics: urlParams.get('metrics') || 'ifHCInOctets,ifHCOutOctets',
                        authToken: urlParams.get('authToken'), // Optional - no default
                        chartType: urlParams.get('chartType') || 'line',
                        dataType: urlParams.get('dataType') || 'diff', // Rate (diff) or raw counter
                        width: parseInt(urlParams.get('width')) || window.innerWidth,
                        height: parseInt(urlParams.get('height')) || window.innerHeight,
                        name: urlParams.get('name') // Optional custom chart name
                    };
                }

                // Adjust chart dimensions
                this.width = this.config.width - 40; // Account for padding
                this.height = this.config.height - 40;

                console.log('Widget config:', this.config);
                
                // Auto-load data
                this.loadMetricsData();
                
                // Set up automatic reload based on period
                this.setupAutoReload();
            }

            calculateTimeRange(period) {
                const now = Date.now();
                let fromTimestamp, toTimestamp, downsample;

                switch (period.toLowerCase()) {
                    case 'hour':
                        fromTimestamp = now - (60 * 60 * 1000); // 1 hour ago
                        toTimestamp = now;
                        downsample = '1m-avg';
                        break;
                    case 'day':
                        fromTimestamp = now - (24 * 60 * 60 * 1000); // 1 day ago
                        toTimestamp = now;
                        downsample = '1h-avg';
                        break;
                    case 'week':
                        fromTimestamp = now - (7 * 24 * 60 * 60 * 1000); // 1 week ago
                        toTimestamp = now;
                        downsample = '1h-avg';
                        break;
                    case 'month':
                        fromTimestamp = now - (30 * 24 * 60 * 60 * 1000); // 1 month ago
                        toTimestamp = now;
                        downsample = '1d-avg';
                        break;
                    default:
                        // Default to 1 day if invalid period
                        fromTimestamp = now - (24 * 60 * 60 * 1000);
                        toTimestamp = now;
                        downsample = '1h-avg';
                        console.warn(`Invalid period "${period}", defaulting to "day"`);
                }

                console.log(`Period "${period}": from ${new Date(fromTimestamp).toISOString()} to ${new Date(toTimestamp).toISOString()}, downsample: ${downsample}`);
                
                return {
                    fromTimestamp: fromTimestamp.toString(),
                    toTimestamp: toTimestamp.toString(),
                    downsample: downsample
                };
            }

            setupAutoReload() {
                // Clear any existing interval
                if (this.reloadInterval) {
                    clearInterval(this.reloadInterval);
                }

                // Set reload interval based on period
                let reloadIntervalMs;
                if (this.config.period && this.config.period.toLowerCase() === 'hour') {
                    reloadIntervalMs = 60 * 1000; // 1 minute for hour period
                    console.log('Setting up auto-reload every 1 minute for hour period');
                } else {
                    reloadIntervalMs = 60 * 60 * 1000; // 1 hour for other periods
                    console.log('Setting up auto-reload every 1 hour for other periods');
                }

                // Set up the interval
                this.reloadInterval = setInterval(() => {
                    console.log('Auto-reloading widget data...');
                    this.loadMetricsData();
                }, reloadIntervalMs);
            }

            async loadMetricsData() {
                try {
                    // Recalculate time range if using period (for auto-reload)
                    if (this.config.period) {
                        const { fromTimestamp, toTimestamp, downsample } = this.calculateTimeRange(this.config.period);
                        this.config.fromTimestamp = fromTimestamp;
                        this.config.toTimestamp = toTimestamp;
                        this.config.downsample = downsample;
                    }

                    const metrics = this.config.metrics.split(',').map(m => m.trim());
                    const metricsParams = metrics.map(metric => `metrics%5B%5D=${encodeURIComponent(metric)}`).join('&');
                    
                    // Build API URL with optional auth token
                    let apiUrl = `https://bccdemo.cpult.ru/node/api/objects/${this.config.objectId}/history?from=${this.config.fromTimestamp}&to=${this.config.toTimestamp}&downsample=${this.config.downsample}&${metricsParams}`;
                    
                    // Add auth token if provided
                    if (this.config.authToken) {
                        apiUrl += `&auth-token=${this.config.authToken}`;
                    }
                    
                    console.log('Loading data from:', apiUrl);
                    
                    const response = await fetch(apiUrl, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        },
                        mode: 'cors'
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const rawData = await response.json();
                    console.log('Raw API response:', rawData);
                    
                    this.data = this.transformApiData(rawData);
                    console.log('Transformed data:', this.data);
                    
                    // Calculate differences if data type is 'diff'
                    if (this.config.dataType === 'diff') {
                        this.calculateDifferences();
                    }
                    
                    this.createChart();
                } catch (error) {
                    console.error('Error loading metrics data:', error);
                    this.showError(`Failed to load data: ${error.message}`);
                }
            }

            transformApiData(rawData) {
                const transformedData = [];
                
                if (!Array.isArray(rawData) || rawData.length === 0) {
                    console.warn('No data received from API');
                    return [];
                }
                
                // Get all unique timestamps from all metrics
                const allTimestamps = new Set();
                rawData.forEach(metricData => {
                    if (metricData.dps && Array.isArray(metricData.dps)) {
                        metricData.dps.forEach(([timestamp]) => {
                            allTimestamps.add(timestamp);
                        });
                    }
                });
                
                // Sort timestamps
                const sortedTimestamps = Array.from(allTimestamps).sort((a, b) => a - b);
                
                // Create data points for each timestamp
                sortedTimestamps.forEach(timestamp => {
                    const dataPoint = {
                        timestamp: timestamp,
                        time: new Date(timestamp)
                    };
                    
                    // Add values for each metric
                    rawData.forEach(metricData => {
                        const metricName = metricData.metric;
                        const dpsEntry = metricData.dps.find(([ts]) => ts === timestamp);
                        if (dpsEntry) {
                            dataPoint[metricName] = dpsEntry[1];
                        }
                    });
                    
                    transformedData.push(dataPoint);
                });
                
                return transformedData;
            }

            calculateDifferences() {
                const metrics = this.config.metrics.split(',').map(m => m.trim());
                
                // Calculate differences between neighboring values for each metric
                metrics.forEach(metric => {
                    for (let i = 1; i < this.data.length; i++) {
                        const currentValue = this.data[i][metric] || 0;
                        const previousValue = this.data[i-1][metric] || 0;
                        const difference = currentValue - previousValue;
                        
                        // Store the difference in a new field
                        this.data[i][`${metric}_diff`] = difference;
                    }
                    
                    // For the first data point, set difference to 0
                    this.data[0][`${metric}_diff`] = 0;
                });
                
                // Remove data points with negative differences
                const originalLength = this.data.length;
                this.data = this.data.filter((point, index) => {
                    const hasNegativeDiff = metrics.some(metric => {
                        const diff = point[`${metric}_diff`];
                        return diff < 0;
                    });
                    
                    if (hasNegativeDiff) {
                        console.log(`Removing data point ${index} due to negative difference`);
                    }
                    
                    return !hasNegativeDiff;
                });
                
                const removedCount = originalLength - this.data.length;
                if (removedCount > 0) {
                    console.log(`Removed ${removedCount} data points with negative differences`);
                }
                
                console.log('Calculated differences for metrics:', metrics);
            }

            showError(message) {
                const chartContainer = d3.select('#chart');
                chartContainer.html(`<div class="error">${message}</div>`);
            }

            createChart() {
                const chartContainer = d3.select('#chart');
                chartContainer.html('');

                if (this.data.length === 0) {
                    this.showError('No data available');
                    return;
                }

                const svg = chartContainer
                    .append('svg')
                    .attr('width', this.width)
                    .attr('height', this.height)
                    .attr('viewBox', `0 0 ${this.width} ${this.height}`);

                const chartGroup = svg.append('g')
                    .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`);

                const chartWidth = this.width - this.margin.left - this.margin.right;
                const chartHeight = this.height - this.margin.top - this.margin.bottom;

                if (this.config.chartType === 'line') {
                    this.createLineChart(chartGroup, chartWidth, chartHeight);
                } else {
                    this.createBarChart(chartGroup, chartWidth, chartHeight);
                }

                this.createLegend();
            }

            createLineChart(chartGroup, width, height) {
                const metrics = this.config.metrics.split(',').map(m => m.trim());
                
                // Filter data to remove first point when showing differences
                const chartData = this.config.dataType === 'diff' ? this.data.slice(1) : this.data;
                
                const xScale = d3.scaleTime()
                    .domain(d3.extent(chartData, d => d.time))
                    .range([0, width]);

                // Use appropriate values for Y scale based on data type with 10% padding
                const allValues = chartData.flatMap(d => 
                    metrics.map(m => this.config.dataType === 'diff' ? (d[`${m}_diff`] || 0) : (d[m] || 0))
                );
                const minValue = d3.min(allValues);
                const maxValue = d3.max(allValues);
                const dataRange = maxValue - minValue;
                const padding = dataRange * 0.1; // 10% of data variation
                
                const yScale = d3.scaleLinear()
                    .domain([minValue - padding, maxValue + padding])
                    .range([height, 0]);

                // Chart title will be shown in the bottom legend instead

                // Calculate number of ticks based on chart width
                const xTicks = Math.max(2, Math.min(8, Math.floor(width / 80))); // 2-8 ticks based on width
                const yTicks = Math.max(3, Math.min(6, Math.floor(height / 60))); // 3-6 ticks based on height

                // Add axes
                const xAxis = d3.axisBottom(xScale)
                    .ticks(xTicks)
                    .tickFormat(d3.timeFormat(width < 400 ? '%H:%M' : '%m/%d %H:%M')); // Shorter format for small screens
                
                const yAxis = d3.axisLeft(yScale)
                    .tickFormat(d => {
                        if (d >= Math.pow(1024, 3)) return d3.format('.1f')(d / Math.pow(1024, 3)) + 'G';
                        if (d >= Math.pow(1024, 2)) return d3.format('.1f')(d / Math.pow(1024, 2)) + 'M';
                        if (d >= 1024) return d3.format('.1f')(d / 1024) + 'K';
                        return d3.format(',.0f')(d);
                    })
                    .ticks(yTicks);

                chartGroup.append('g')
                    .attr('class', 'axis')
                    .attr('transform', `translate(0, ${height})`)
                    .call(xAxis);

                chartGroup.append('g')
                    .attr('class', 'axis')
                    .call(yAxis);

                // Add grid
                chartGroup.append('g')
                    .attr('class', 'grid')
                    .attr('transform', `translate(0, ${height})`)
                    .call(d3.axisBottom(xScale).tickSize(-height).tickFormat(''));

                chartGroup.append('g')
                    .attr('class', 'grid')
                    .call(d3.axisLeft(yScale).tickSize(-width).tickFormat(''));

                // Create line generator
                const line = d3.line()
                    .x(d => xScale(d.time))
                    .y(d => yScale(d.value))
                    .curve(d3.curveLinear);

                // Add lines for each metric
                metrics.forEach((metric, index) => {
                    const lineData = chartData.map(d => ({
                        time: d.time,
                        value: this.config.dataType === 'diff' ? (d[`${metric}_diff`] || 0) : (d[metric] || 0),
                        counterValue: d[metric] || 0,
                        rateValue: d[`${metric}_diff`] || 0
                    }));

                    chartGroup.append('path')
                        .datum(lineData)
                        .attr('class', 'line-path')
                        .attr('fill', 'none')
                        .attr('stroke', this.color(index))
                        .attr('stroke-width', this.config.dataType === 'diff' ? this.strokeWidth + 1 : this.strokeWidth)
                        .attr('d', line);

                    // Add data points
                    chartGroup.selectAll(`.points-${index}`)
                        .data(lineData)
                        .enter()
                        .append('circle')
                        .attr('class', `data-point points-${index}`)
                        .attr('cx', d => xScale(d.time))
                        .attr('cy', d => yScale(d.value))
                        .attr('r', this.config.dataType === 'diff' ? this.pointSize + 1 : this.pointSize)
                        .attr('fill', this.color(index))
                        .attr('stroke', 'white')
                        .attr('stroke-width', 1)
                        .on('mouseover', (event, d) => {
                            this.showTooltip(event, d, metric);
                        })
                        .on('mouseout', () => {
                            this.hideTooltip();
                        });
                });
            }

            createBarChart(chartGroup, width, height) {
                const metrics = this.config.metrics.split(',').map(m => m.trim());
                
                // Filter data to remove first point when showing differences
                const chartData = this.config.dataType === 'diff' ? this.data.slice(1) : this.data;
                
                const xScale = d3.scaleBand()
                    .domain(chartData.map(d => d.time))
                    .range([0, width])
                    .padding(0.1);

                // Use appropriate values for Y scale based on data type with 10% padding
                const allValues = chartData.flatMap(d => 
                    metrics.map(m => this.config.dataType === 'diff' ? (d[`${m}_diff`] || 0) : (d[m] || 0))
                );
                const minValue = d3.min(allValues);
                const maxValue = d3.max(allValues);
                const dataRange = maxValue - minValue;
                const padding = dataRange * 0.1; // 10% of data variation
                
                const yScale = d3.scaleLinear()
                    .domain([minValue - padding, maxValue + padding])
                    .range([height, 0]);

                // Chart title will be shown in the bottom legend instead

                // Calculate number of ticks based on chart width
                const xTicks = Math.max(2, Math.min(8, Math.floor(width / 80))); // 2-8 ticks based on width
                const yTicks = Math.max(3, Math.min(6, Math.floor(height / 60))); // 3-6 ticks based on height

                // Add axes
                const xAxis = d3.axisBottom(xScale)
                    .ticks(xTicks);
                
                const yAxis = d3.axisLeft(yScale)
                    .tickFormat(d => {
                        if (d >= Math.pow(1024, 3)) return d3.format('.1f')(d / Math.pow(1024, 3)) + 'G';
                        if (d >= Math.pow(1024, 2)) return d3.format('.1f')(d / Math.pow(1024, 2)) + 'M';
                        if (d >= 1024) return d3.format('.1f')(d / 1024) + 'K';
                        return d3.format(',.0f')(d);
                    })
                    .ticks(yTicks);

                chartGroup.append('g')
                    .attr('class', 'axis')
                    .attr('transform', `translate(0, ${height})`)
                    .call(xAxis);

                chartGroup.append('g')
                    .attr('class', 'axis')
                    .call(yAxis);

                // Add bars for each metric
                metrics.forEach((metric, index) => {
                    chartGroup.selectAll(`.bars-${index}`)
                        .data(chartData)
                        .enter()
                        .append('rect')
                        .attr('class', `bar bars-${index}`)
                        .attr('x', d => xScale(d.time))
                        .attr('y', d => yScale(this.config.dataType === 'diff' ? (d[`${metric}_diff`] || 0) : (d[metric] || 0)))
                        .attr('width', xScale.bandwidth())
                        .attr('height', d => height - yScale(this.config.dataType === 'diff' ? (d[`${metric}_diff`] || 0) : (d[metric] || 0)))
                        .attr('fill', this.color(index))
                        .attr('opacity', this.config.dataType === 'diff' ? 0.9 : 0.8)
                        .on('mouseover', (event, d) => {
                            this.showTooltip(event, d, metric);
                        })
                        .on('mouseout', () => {
                            this.hideTooltip();
                        });
                });
            }

            createLegend() {
                const legend = d3.select('#legend');
                legend.html('');

                const metrics = this.config.metrics.split(',').map(m => m.trim());
                
                // Add chart title first - use custom name if provided, otherwise default
                let titleText;
                if (this.config.name) {
                    titleText = this.config.name;
                } else {
                    titleText = this.config.dataType === 'diff' ? 'ðŸ“ˆ Rate Chart' : 'ðŸ“Š Counter Chart';
                }
                const periodText = this.config.period ? ` (${this.config.period})` : '';
                
                legend.append('div')
                    .attr('class', 'legend-item chart-title-bottom')
                    .text(titleText + periodText);
                
                // Add metrics
                metrics.forEach((metric, index) => {
                    const legendItem = legend.append('div')
                        .attr('class', 'legend-item');

                    legendItem.append('div')
                        .attr('class', 'legend-color')
                        .style('background-color', this.color(index));

                    const label = this.config.dataType === 'diff' ? `${metric} (Rate)` : `${metric} (Counter)`;
                    legendItem.append('span')
                        .text(label);
                });
            }

            showTooltip(event, data, metric) {
                const tooltip = d3.select('#tooltip');
                const formatValue = d3.format(',.0f');
                const formatTime = d3.timeFormat('%Y-%m-%d %H:%M:%S');
                
                // Get both counter and rate values
                const counterValue = data.counterValue || data.value || 0;
                const rateValue = data.rateValue || data.value || 0;
                
                // Format large numbers with appropriate units (1024-based for traffic data)
                let displayCounter = formatValue(counterValue);
                if (counterValue >= Math.pow(1024, 3)) {
                    displayCounter = d3.format('.2f')(counterValue / Math.pow(1024, 3)) + 'G';
                } else if (counterValue >= Math.pow(1024, 2)) {
                    displayCounter = d3.format('.2f')(counterValue / Math.pow(1024, 2)) + 'M';
                } else if (counterValue >= 1024) {
                    displayCounter = d3.format('.2f')(counterValue / 1024) + 'K';
                }
                
                let displayRate = formatValue(rateValue);
                if (rateValue >= Math.pow(1024, 3)) {
                    displayRate = d3.format('.2f')(rateValue / Math.pow(1024, 3)) + 'G';
                } else if (rateValue >= Math.pow(1024, 2)) {
                    displayRate = d3.format('.2f')(rateValue / Math.pow(1024, 2)) + 'M';
                } else if (rateValue >= 1024) {
                    displayRate = d3.format('.2f')(rateValue / 1024) + 'K';
                }
                
                let tooltipContent = `<strong>${metric}</strong><br>Time: ${formatTime(data.time)}<br>`;
                
                if (this.config.dataType === 'diff') {
                    tooltipContent += `Rate: ${displayRate} (${formatValue(rateValue)})<br>Counter: ${displayCounter} (${formatValue(counterValue)})`;
                } else {
                    tooltipContent += `Counter: ${displayCounter} (${formatValue(counterValue)})`;
                }
                
                tooltip.style('opacity', 1)
                    .html(tooltipContent)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            }

            hideTooltip() {
                d3.select('#tooltip').style('opacity', 0);
            }
        }

        // Initialize the widget when the page loads
        let widget;
        document.addEventListener('DOMContentLoaded', function() {
            widget = new SaymonWidget();
        });

        // Cleanup when page is unloaded
        window.addEventListener('beforeunload', function() {
            if (widget && widget.reloadInterval) {
                clearInterval(widget.reloadInterval);
                console.log('Widget auto-reload stopped');
            }
        });
    </script>
</body>
</html>
