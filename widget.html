<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAYMON Metrics Widget</title>
    <script src="d3.v7.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: transparent;
            overflow: hidden;
        }
        .widget-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        .chart-container {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }
        .chart {
            width: 100%;
            height: calc(100% - 40px);
            border-radius: 6px;
            overflow: visible;
        }
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #666;
            font-size: 16px;
        }
        .error {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #666;
            font-size: 14px;
            text-align: center;
            padding: 20px;
        }
        .axis path, .axis line { stroke: #cbd5e0; }
        .axis text { fill: #4a5568; font-size: 11px; }
        .grid line { stroke: #e2e8f0; stroke-opacity: 0.7; }
        .grid path { stroke-width: 0; }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
        }
        .legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 12px;
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 10px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            color: #4a5568;
            white-space: nowrap;
        }
        .legend-color {
            width: 8px;
            height: 8px;
            border-radius: 2px;
        }
        .chart-title-bottom {
            font-weight: bold;
            color: #2d3748;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="widget-container">
        <div class="chart-container">
            <div id="chart" class="chart">
                <div class="loading">Loading chart...</div>
            </div>
            <div class="tooltip" id="tooltip"></div>
            <div class="legend" id="legend"></div>
        </div>
    </div>

    <script>
        class SaymonWidget {
            constructor() {
                this.data = [];
                this.margin = { top: 10, right: 80, bottom: 40, left: 50 };
                this.color = d3.scaleOrdinal(d3.schemeCategory10);
                this.strokeWidth = 2;
                this.pointSize = 2;
                this.reloadInterval = null;
                
                this.init();
            }

            init() {
                // Parse URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                
                // Check if period is specified
                const period = urlParams.get('period');
                // Optional divider parameter
                const dividerParam = urlParams.get('divider');
                const divider = dividerParam ? parseFloat(dividerParam) : null;
                
                if (period) {
                    // First set up basic config to get forecast parameter
                    const forecast = urlParams.get('forecast') === 'true';
                    
                    // Calculate time range and downsample based on period
                    const { fromTimestamp, toTimestamp, downsample } = this.calculateTimeRange(period, forecast);
                    
                    this.config = {
                        objectId: urlParams.get('objectId') || '67cb1f1f120ab073c5adb8a2',
                        fromTimestamp: fromTimestamp,
                        toTimestamp: toTimestamp,
                        downsample: downsample,
                        metrics: urlParams.get('metrics') || 'ifHCInOctets,ifHCOutOctets',
                        authToken: urlParams.get('authToken'), // Optional - no default
                        chartType: urlParams.get('chartType') || 'line',
                        dataType: urlParams.get('dataType') || 'diff', // Rate (diff), speed, or raw counter
                        width: parseInt(urlParams.get('width')) || window.innerWidth,
                        height: parseInt(urlParams.get('height')) || window.innerHeight,
                        period: period,
                        name: urlParams.get('name'), // Optional custom chart name
                        divider: !isNaN(divider) && divider > 0 ? divider : null,
                        forecast: forecast, // Forecast mode parameter
                        skipzero: urlParams.get('skipzero') === 'true', // Skip zero values parameter
                        nowLineColor: urlParams.get('nowLineColor') || '#ff6b6b' // Now line color parameter
                    };
                } else {
                    // Use explicit from/to/downsample if period not specified
                    this.config = {
                        objectId: urlParams.get('objectId') || '67cb1f1f120ab073c5adb8a2',
                        fromTimestamp: urlParams.get('from') || '1756497678991',
                        toTimestamp: urlParams.get('to') || '1756592718991',
                        downsample: urlParams.get('downsample') || '5m-avg',
                        metrics: urlParams.get('metrics') || 'ifHCInOctets,ifHCOutOctets',
                        authToken: urlParams.get('authToken'), // Optional - no default
                        chartType: urlParams.get('chartType') || 'line',
                        dataType: urlParams.get('dataType') || 'diff', // Rate (diff), speed, or raw counter
                        width: parseInt(urlParams.get('width')) || window.innerWidth,
                        height: parseInt(urlParams.get('height')) || window.innerHeight,
                        name: urlParams.get('name'), // Optional custom chart name
                        divider: !isNaN(divider) && divider > 0 ? divider : null,
                        forecast: urlParams.get('forecast') === 'true', // Forecast mode parameter
                        skipzero: urlParams.get('skipzero') === 'true', // Skip zero values parameter
                        nowLineColor: urlParams.get('nowLineColor') || '#ff6b6b' // Now line color parameter
                    };
                }

                // Adjust chart dimensions
                this.width = this.config.width - 40; // Account for padding
                this.height = this.config.height - 40;

                console.log('Widget config:', this.config);
                
                // Auto-load data
                this.loadMetricsData();
                
                // Set up automatic reload based on period
                this.setupAutoReload();
            }

            calculateTimeRange(period, forecast = false) {
                const now = Date.now();
                let fromTimestamp, toTimestamp, downsample;

                switch (period.toLowerCase()) {
                    case 'hour':
                        fromTimestamp = now - (60 * 60 * 1000); // 1 hour ago
                        toTimestamp = now;
                        downsample = '1m-avg';
                        break;
                    case 'day':
                        fromTimestamp = now - (24 * 60 * 60 * 1000); // 1 day ago
                        toTimestamp = now;
                        downsample = '1h-avg';
                        break;
                    case 'week':
                        fromTimestamp = now - (7 * 24 * 60 * 60 * 1000); // 1 week ago
                        toTimestamp = now;
                        downsample = '1h-avg';
                        break;
                    case 'month':
                        fromTimestamp = now - (30 * 24 * 60 * 60 * 1000); // 1 month ago
                        toTimestamp = now;
                        downsample = '1d-avg';
                        break;
                    default:
                        // Default to 1 day if invalid period
                        fromTimestamp = now - (24 * 60 * 60 * 1000);
                        toTimestamp = now;
                        downsample = '1h-avg';
                        console.warn(`Invalid period "${period}", defaulting to "day"`);
                }

                // Apply forecast mode: extend time range by 30% if forecast is enabled
                if (forecast) {
                    const timeRange = toTimestamp - fromTimestamp;
                    const forecastExtension = timeRange * 0.3; // 30% extension
                    const originalToTimestamp = toTimestamp;
                    toTimestamp = toTimestamp + forecastExtension;
                    console.log(`Forecast mode enabled: extending time range by 30% (${Math.round(forecastExtension / (60 * 1000))} minutes)`);
                    console.log(`Original toTimestamp: ${new Date(originalToTimestamp).toISOString()}`);
                    console.log(`Extended toTimestamp: ${new Date(toTimestamp).toISOString()}`);
                    console.log(`Forecast extension: ${Math.round(forecastExtension / (60 * 1000))} minutes into the future`);
                }

                console.log(`Period "${period}": from ${new Date(fromTimestamp).toISOString()} to ${new Date(toTimestamp).toISOString()}, downsample: ${downsample}`);
                
                return {
                    fromTimestamp: fromTimestamp.toString(),
                    toTimestamp: toTimestamp.toString(),
                    downsample: downsample
                };
            }

            setupAutoReload() {
                // Clear any existing interval
                if (this.reloadInterval) {
                    clearInterval(this.reloadInterval);
                }

                // Set reload interval based on period
                let reloadIntervalMs;
                if (this.config.period && this.config.period.toLowerCase() === 'hour') {
                    reloadIntervalMs = 60 * 1000; // 1 minute for hour period
                    console.log('Setting up auto-reload every 1 minute for hour period');
                } else {
                    reloadIntervalMs = 60 * 60 * 1000; // 1 hour for other periods
                    console.log('Setting up auto-reload every 1 hour for other periods');
                }

                // Set up the interval
                this.reloadInterval = setInterval(() => {
                    console.log('Auto-reloading widget data...');
                    this.loadMetricsData();
                }, reloadIntervalMs);
            }

            getTimeFormat() {
                if (!this.config.period) {
                    // Default format for custom time ranges
                    return d3.timeFormat('%m/%d %H:%M');
                }

                switch (this.config.period.toLowerCase()) {
                    case 'hour':
                        return d3.timeFormat('%H:%M'); // Hours:Minutes
                    case 'day':
                        return d3.timeFormat('%H:%M'); // Hours:Minutes
                    case 'week':
                        return d3.timeFormat('%m/%d'); // Month/Day
                    case 'month':
                        return d3.timeFormat('%m/%d'); // Month/Day
                    default:
                        return d3.timeFormat('%m/%d %H:%M'); // Default format
                }
            }

            getMetricValue(dataPoint, metric) {
                if (this.config.dataType === 'diff') return dataPoint[`${metric}_diff`] || 0;
                if (this.config.dataType === 'speed') return dataPoint[`${metric}_speed`] || 0;
                return dataPoint[metric] || 0;
            }

            async loadMetricsData() {
                try {
                    // Recalculate time range if using period (for auto-reload)
                    if (this.config.period) {
                        const { fromTimestamp, toTimestamp, downsample } = this.calculateTimeRange(this.config.period, this.config.forecast);
                        this.config.fromTimestamp = fromTimestamp;
                        this.config.toTimestamp = toTimestamp;
                        this.config.downsample = downsample;
                    }

                    const metrics = this.config.metrics.split(',').map(m => m.trim());
                    const parsedMetrics = this.parseMetrics(metrics);
                    
                    // Group metrics by object ID
                    const metricsByObject = {};
                    parsedMetrics.forEach(metric => {
                        if (!metricsByObject[metric.objectId]) {
                            metricsByObject[metric.objectId] = [];
                        }
                        metricsByObject[metric.objectId].push(metric.metricName);
                    });
                    
                    console.log('Loading data from multiple objects:', metricsByObject);
                    
                    // Load data from API
                    const allData = [];
                    for (const [objectId, objectMetrics] of Object.entries(metricsByObject)) {
                        const metricsParams = objectMetrics.map(metric => `metrics%5B%5D=${encodeURIComponent(metric)}`).join('&');
                        
                        // Use extended timestamp for API calls when forecast mode is enabled
                        const apiFromTimestamp = this.config.fromTimestamp;
                        const apiToTimestamp = this.config.toTimestamp; // This already includes forecast extension
                        
                        let apiUrl = `https://bccdemo.cpult.ru/node/api/objects/${objectId}/history?from=${apiFromTimestamp}&to=${apiToTimestamp}&downsample=${this.config.downsample}&${metricsParams}`;
                        
                        // Add auth token if provided
                        if (this.config.authToken) {
                            apiUrl += `&auth-token=${this.config.authToken}`;
                        }
                        
                        console.log('Loading data from:', apiUrl);
                        console.log(`API time range: ${new Date(parseInt(apiFromTimestamp)).toISOString()} to ${new Date(parseInt(apiToTimestamp)).toISOString()}`);
                        const response = await fetch(apiUrl, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json'
                            },
                            mode: 'cors'
                        });
                        
                        if (!response.ok) {
                            console.error(`HTTP error! status: ${response.status}`);
                            this.showError('Data source is not selected or load failed');
                            return;
                        }
                        
                        const objectData = await response.json();
                        allData.push(...objectData);
                    }
                    this.data = this.transformApiData(allData);
                    
                    // Apply zero value filtering if skipzero is enabled
                    if (this.config.skipzero) {
                        const originalLength = this.data.length;
                        this.data = this.filterZeroValues(this.data);
                        const filteredLength = this.data.length;
                        console.log(`Skipzero enabled: filtered ${originalLength - filteredLength} zero-value data points, ${filteredLength} remaining`);
                    }
                    
                    // Fallback to sample data if no real data available
                    if (this.data.length === 0) {
                        console.log('No real data available, using sample data');
                        this.generateSampleData();
                        
                        // Apply zero value filtering to sample data if skipzero is enabled
                        if (this.config.skipzero) {
                            const originalLength = this.data.length;
                            this.data = this.filterZeroValues(this.data);
                            const filteredLength = this.data.length;
                            console.log(`Skipzero enabled (sample data): filtered ${originalLength - filteredLength} zero-value data points, ${filteredLength} remaining`);
                        }
                    }
                    
                    // Only proceed if we have data
                    if (this.data.length > 0) {
                        // Calculate differences or speed based on data type
                        if (this.config.dataType === 'diff') {
                            this.calculateDifferences();
                        } else if (this.config.dataType === 'speed') {
                            this.calculateSpeed();
                        }
                        
                        this.createChart();
                    } else {
                        // No data available
                        this.showError('Data source is not selected or load failed');
                    }
                } catch (error) {
                    console.error('Error loading metrics data:', error);
                    this.showError('Data source is not selected or load failed');
                }
            }

            generateSampleData() {
                // Generate sample data for demonstration
                this.data = [];
                const fromTime = parseInt(this.config.fromTimestamp);
                const toTime = parseInt(this.config.toTimestamp);
                const metrics = this.config.metrics.split(',').map(m => m.trim());
                const parsedMetrics = this.parseMetrics(metrics);
                
                // Calculate the original time range (without forecast extension)
                const originalTimeRange = this.config.forecast ? (toTime - fromTime) / 1.3 : (toTime - fromTime);
                const originalToTime = fromTime + originalTimeRange;
                
                const timeStep = (toTime - fromTime) / 50; // 50 data points for more detail
                
                // Generate counter data with realistic patterns
                let currentValues = {};
                parsedMetrics.forEach((parsedMetric, index) => {
                    const metric = parsedMetric.metricName;
                    currentValues[metric] = Math.random() * 10000 + 1000; // Higher starting values
                });
                
                for (let i = 0; i < 50; i++) {
                    const timestamp = fromTime + (i * timeStep);
                    const dataPoint = {
                        timestamp: timestamp,
                        time: new Date(timestamp)
                    };
                    
                    // Check if this is forecast data (beyond original time range)
                    const isForecastData = this.config.forecast && timestamp > originalToTime;
                    
                    parsedMetrics.forEach((parsedMetric, index) => {
                        const metric = parsedMetric.metricName;
                        
                        if (isForecastData) {
                            // Generate forecast data (trending based on recent data)
                            const recentData = this.data.slice(-5); // Get last 5 data points
                            if (recentData.length > 0) {
                                // Calculate trend from recent data
                                const recentValues = recentData.map(d => d[metric] || 0);
                                const trend = recentValues.length > 1 ? 
                                    (recentValues[recentValues.length - 1] - recentValues[0]) / recentValues.length : 0;
                                
                                // Apply trend with some randomness
                                const forecastIncrement = trend + (Math.random() - 0.5) * 100;
                                currentValues[metric] += forecastIncrement;
                            } else {
                                // Fallback to normal increment if no recent data
                                currentValues[metric] += Math.random() * 200 + 100;
                            }
                        } else {
                            // Simulate realistic data with varying intensity
                            let increment;
                            if (i < 10) {
                                // Low activity period
                                increment = Math.random() * 100 + 50;
                            } else if (i < 20) {
                                // Medium activity period
                                increment = Math.random() * 300 + 200;
                            } else if (i < 35) {
                                // High activity period (peak)
                                increment = Math.random() * 800 + 500;
                            } else if (i < 45) {
                                // Medium activity period
                                increment = Math.random() * 300 + 200;
                            } else {
                                // Low activity period
                                increment = Math.random() * 100 + 50;
                            }
                            
                            // Add some random spikes
                            if (Math.random() < 0.1) { // 10% chance of spike
                                increment *= 2;
                            }
                            
                            currentValues[metric] += increment;
                        }
                        
                        dataPoint[metric] = currentValues[metric];
                    });
                    
                    this.data.push(dataPoint);
                }
            }

            filterZeroValues(data) {
                if (!this.config.skipzero) {
                    return data;
                }
                
                const metrics = this.config.metrics.split(',').map(m => m.trim());
                const parsedMetrics = this.parseMetrics(metrics);
                
                return data.filter(dataPoint => {
                    // Check if any metric has a non-zero value (keep data points with at least one non-zero metric)
                    return parsedMetrics.some(parsedMetric => {
                        const metric = parsedMetric.metricName;
                        const value = this.getMetricValue(dataPoint, metric);
                        return value !== 0 && value !== null && value !== undefined;
                    });
                });
            }

            parseMetrics(metrics) {
                return metrics.map(metric => {
                    // Check if metric contains object ID in format {{objectId:metricName}}
                    const objectIdMatch = metric.match(/^\{\{([^:]+):(.+)\}\}$/);
                    if (objectIdMatch) {
                        return {
                            objectId: objectIdMatch[1],
                            metricName: objectIdMatch[2],
                            originalMetric: metric
                        };
                    } else {
                        // Use default object ID from config
                        return {
                            objectId: this.config.objectId,
                            metricName: metric,
                            originalMetric: metric
                        };
                    }
                });
            }

            transformApiData(rawData) {
                const transformedData = [];
                
                if (!Array.isArray(rawData) || rawData.length === 0) {
                    console.warn('No data received from API');
                    return [];
                }
                
                // Get all unique timestamps from all metrics
                const allTimestamps = new Set();
                rawData.forEach(metricData => {
                    if (metricData.dps && Array.isArray(metricData.dps)) {
                        metricData.dps.forEach(([timestamp]) => {
                            allTimestamps.add(timestamp);
                        });
                    }
                });
                
                // Sort timestamps
                const sortedTimestamps = Array.from(allTimestamps).sort((a, b) => a - b);
                
                // Create data points for each timestamp
                sortedTimestamps.forEach(timestamp => {
                    const dataPoint = {
                        timestamp: timestamp,
                        time: new Date(timestamp)
                    };
                    
                    // Add values for each metric
                    rawData.forEach(metricData => {
                        const metricName = metricData.metric;
                        const dpsEntry = metricData.dps.find(([ts]) => ts === timestamp);
                        if (dpsEntry) {
                            const rawValue = dpsEntry[1];
                            const divider = this.config?.divider;
                            dataPoint[metricName] = divider ? (rawValue / divider) : rawValue;
                        }
                    });
                    
                    transformedData.push(dataPoint);
                });
                
                return transformedData;
            }

            calculateDifferences() {
                const metrics = this.config.metrics.split(',').map(m => m.trim());
                const parsedMetrics = this.parseMetrics(metrics);
                
                // Calculate differences between neighboring values for each metric
                parsedMetrics.forEach(parsedMetric => {
                    const metric = parsedMetric.metricName;
                    for (let i = 1; i < this.data.length; i++) {
                        const currentValue = this.data[i][metric] || 0;
                        const previousValue = this.data[i-1][metric] || 0;
                        const difference = currentValue - previousValue;
                        
                        // Store the difference in a new field
                        this.data[i][`${metric}_diff`] = difference;
                    }
                    
                    // For the first data point, set difference to 0
                    this.data[0][`${metric}_diff`] = 0;
                });
                
                // Remove data points with negative differences
                const originalLength = this.data.length;
                this.data = this.data.filter((point, index) => {
                    const hasNegativeDiff = metrics.some(metric => {
                        const diff = point[`${metric}_diff`];
                        return diff < 0;
                    });
                    
                    if (hasNegativeDiff) {
                        console.log(`Removing data point ${index} due to negative difference`);
                    }
                    
                    return !hasNegativeDiff;
                });
                
                const removedCount = originalLength - this.data.length;
                if (removedCount > 0) {
                    console.log(`Removed ${removedCount} data points with negative differences`);
                }
                
                console.log('Calculated differences for metrics:', metrics);
            }

            calculateSpeed() {
                const metrics = this.config.metrics.split(',').map(m => m.trim());
                const parsedMetrics = this.parseMetrics(metrics);
                
                // First calculate differences
                this.calculateDifferences();
                
                // Then calculate speed (difference per unit time)
                parsedMetrics.forEach(parsedMetric => {
                    const metric = parsedMetric.metricName;
                    for (let i = 1; i < this.data.length; i++) {
                        const currentTime = this.data[i].timestamp;
                        const previousTime = this.data[i-1].timestamp;
                        const timeDiff = (currentTime - previousTime) / 1000; // Convert to seconds
                        
                        const diff = this.data[i][`${metric}_diff`] || 0;
                        
                        // Calculate speed: difference per second
                        const speed = timeDiff > 0 ? diff / timeDiff : 0;
                        
                        // Store the speed in a new field
                        this.data[i][`${metric}_speed`] = speed;
                    }
                    
                    // For the first data point, set speed to 0
                    this.data[0][`${metric}_speed`] = 0;
                });
                
                console.log('Calculated speed for metrics:', metrics);
            }

            showError(message) {
                const chartContainer = d3.select('#chart');
                chartContainer.html(`<div class="error">${message}</div>`);
            }

            createChart() {
                const chartContainer = d3.select('#chart');
                chartContainer.html('');

                if (this.data.length === 0) {
                    this.showError('Data source is not selected or load failed');
                    return;
                }

                const svg = chartContainer
                    .append('svg')
                    .attr('width', this.width)
                    .attr('height', this.height)
                    .attr('viewBox', `0 0 ${this.width} ${this.height}`);

                const chartGroup = svg.append('g')
                    .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`);

                const chartWidth = this.width - this.margin.left - this.margin.right;
                const chartHeight = this.height - this.margin.top - this.margin.bottom;

                if (this.config.chartType === 'line') {
                    this.createLineChart(chartGroup, chartWidth, chartHeight);
                } else if (this.config.chartType === 'bar') {
                    this.createBarChart(chartGroup, chartWidth, chartHeight);
                } else if (this.config.chartType === 'dots') {
                    this.createDotsChart(chartGroup, chartWidth, chartHeight);
                }

                this.createLegend();
            }

            createLineChart(chartGroup, width, height) {
                const metrics = this.config.metrics.split(',').map(m => m.trim());
                const parsedMetrics = this.parseMetrics(metrics);
                
                // Filter data to remove first point when showing differences or speed
                let chartData = (this.config.dataType === 'diff' || this.config.dataType === 'speed') ? this.data.slice(1) : this.data;
                
                // Apply zero value filtering if skipzero is enabled
                if (this.config.skipzero) {
                    chartData = this.filterZeroValues(chartData);
                }
                
                const xScale = d3.scaleTime()
                    .domain(d3.extent(chartData, d => d.time))
                    .range([0, width]);

                // Use appropriate values for Y scale based on data type with 10% padding
                const allValues = chartData.flatMap(d => 
                    metrics.map(m => {
                        if (this.config.dataType === 'diff') return d[`${m}_diff`] || 0;
                        if (this.config.dataType === 'speed') return d[`${m}_speed`] || 0;
                        return d[m] || 0;
                    })
                );
                const minValue = d3.min(allValues);
                const maxValue = d3.max(allValues);
                const dataRange = maxValue - minValue;
                const padding = dataRange * 0.1; // 10% of data variation
                
                const yScale = d3.scaleLinear()
                    .domain([minValue - padding, maxValue + padding])
                    .range([height, 0]);

                // Chart title will be shown in the bottom legend instead

                // Calculate number of ticks based on chart width
                const xTicks = Math.max(2, Math.min(8, Math.floor(width / 80))); // 2-8 ticks based on width
                const yTicks = Math.max(3, Math.min(6, Math.floor(height / 60))); // 3-6 ticks based on height

                // Add axes
                const xAxis = d3.axisBottom(xScale)
                    .ticks(xTicks)
                    .tickFormat(this.getTimeFormat());
                
                const yAxis = d3.axisLeft(yScale)
                    .tickFormat(d => {
                        if (d >= Math.pow(1024, 3)) return d3.format('.1f')(d / Math.pow(1024, 3)) + 'G';
                        if (d >= Math.pow(1024, 2)) return d3.format('.1f')(d / Math.pow(1024, 2)) + 'M';
                        if (d >= 1024) return d3.format('.1f')(d / 1024) + 'K';
                        return d3.format(',.0f')(d);
                    })
                    .ticks(yTicks);

                chartGroup.append('g')
                    .attr('class', 'axis')
                    .attr('transform', `translate(0, ${height})`)
                    .call(xAxis);

                chartGroup.append('g')
                    .attr('class', 'axis')
                    .call(yAxis);

                // Add grid
                chartGroup.append('g')
                    .attr('class', 'grid')
                    .attr('transform', `translate(0, ${height})`)
                    .call(d3.axisBottom(xScale).tickSize(-height).tickFormat(''));

                chartGroup.append('g')
                    .attr('class', 'grid')
                    .call(d3.axisLeft(yScale).tickSize(-width).tickFormat(''));

                // Add "now" line in forecast mode
                if (this.config.forecast) {
                    const nowTime = new Date();
                    const nowX = xScale(nowTime);
                    
                    chartGroup.append('line')
                        .attr('class', 'now-line')
                        .attr('x1', nowX)
                        .attr('y1', 0)
                        .attr('x2', nowX)
                        .attr('y2', height)
                        .attr('stroke', this.config.nowLineColor || '#ff6b6b')
                        .attr('stroke-width', 2)
                        .attr('stroke-dasharray', '5,5')
                        .attr('opacity', 0.8);
                }

                // Create line generator
                const line = d3.line()
                    .x(d => xScale(d.time))
                    .y(d => yScale(d.value))
                    .curve(d3.curveLinear);

                // Add lines for each metric
                parsedMetrics.forEach((parsedMetric, index) => {
                    const metric = parsedMetric.metricName;
                    let lineData = chartData.map(d => ({
                        time: d.time,
                        value: this.getMetricValue(d, metric),
                        counterValue: d[metric] || 0,
                        rateValue: d[`${metric}_diff`] || 0,
                        speedValue: d[`${metric}_speed`] || 0
                    }));
                    
                    // Filter out zero values for this specific metric if skipzero is enabled
                    if (this.config.skipzero) {
                        lineData = lineData.filter(d => d.value !== 0 && d.value !== null && d.value !== undefined);
                    }

                    chartGroup.append('path')
                        .datum(lineData)
                        .attr('class', 'line-path')
                        .attr('fill', 'none')
                        .attr('stroke', this.color(index))
                        .attr('stroke-width', (this.config.dataType === 'diff' || this.config.dataType === 'speed') ? this.strokeWidth + 1 : this.strokeWidth)
                        .attr('d', line);

                    // Add data points
                    chartGroup.selectAll(`.points-${index}`)
                        .data(lineData)
                        .enter()
                        .append('circle')
                        .attr('class', `data-point points-${index}`)
                        .attr('cx', d => xScale(d.time))
                        .attr('cy', d => yScale(d.value))
                        .attr('r', (this.config.dataType === 'diff' || this.config.dataType === 'speed') ? this.pointSize + 1 : this.pointSize)
                        .attr('fill', this.color(index))
                        .attr('stroke', 'white')
                        .attr('stroke-width', 1)
                        .on('mouseover', (event, d) => {
                            this.showTooltip(event, d, metric);
                        })
                        .on('mouseout', () => {
                            this.hideTooltip();
                        });
                });
            }

            createBarChart(chartGroup, width, height) {
                const metrics = this.config.metrics.split(',').map(m => m.trim());
                const parsedMetrics = this.parseMetrics(metrics);
                
                // Filter data to remove first point when showing differences or speed
                let chartData = (this.config.dataType === 'diff' || this.config.dataType === 'speed') ? this.data.slice(1) : this.data;
                
                // Apply zero value filtering if skipzero is enabled
                if (this.config.skipzero) {
                    chartData = this.filterZeroValues(chartData);
                }
                
                const xScale = d3.scaleBand()
                    .domain(chartData.map(d => d.time))
                    .range([0, width])
                    .padding(0.1);

                // Use appropriate values for Y scale based on data type with 10% padding
                const allValues = chartData.flatMap(d => 
                    metrics.map(m => {
                        if (this.config.dataType === 'diff') return d[`${m}_diff`] || 0;
                        if (this.config.dataType === 'speed') return d[`${m}_speed`] || 0;
                        return d[m] || 0;
                    })
                );
                const minValue = d3.min(allValues);
                const maxValue = d3.max(allValues);
                const dataRange = maxValue - minValue;
                const padding = dataRange * 0.1; // 10% of data variation
                
                const yScale = d3.scaleLinear()
                    .domain([minValue - padding, maxValue + padding])
                    .range([height, 0]);

                // Chart title will be shown in the bottom legend instead

                // Calculate number of ticks based on chart width
                const xTicks = Math.max(2, Math.min(8, Math.floor(width / 80))); // 2-8 ticks based on width
                const yTicks = Math.max(3, Math.min(6, Math.floor(height / 60))); // 3-6 ticks based on height

                // Add axes
                const xAxis = d3.axisBottom(xScale)
                    .ticks(xTicks);
                
                const yAxis = d3.axisLeft(yScale)
                    .tickFormat(d => {
                        if (d >= Math.pow(1024, 3)) return d3.format('.1f')(d / Math.pow(1024, 3)) + 'G';
                        if (d >= Math.pow(1024, 2)) return d3.format('.1f')(d / Math.pow(1024, 2)) + 'M';
                        if (d >= 1024) return d3.format('.1f')(d / 1024) + 'K';
                        return d3.format(',.0f')(d);
                    })
                    .ticks(yTicks);

                chartGroup.append('g')
                    .attr('class', 'axis')
                    .attr('transform', `translate(0, ${height})`)
                    .call(xAxis);

                chartGroup.append('g')
                    .attr('class', 'axis')
                    .call(yAxis);

                // Add "now" line in forecast mode
                if (this.config.forecast) {
                    const nowTime = new Date();
                    const nowX = xScale(nowTime);
                    
                    chartGroup.append('line')
                        .attr('class', 'now-line')
                        .attr('x1', nowX)
                        .attr('y1', 0)
                        .attr('x2', nowX)
                        .attr('y2', height)
                        .attr('stroke', this.config.nowLineColor || '#ff6b6b')
                        .attr('stroke-width', 2)
                        .attr('stroke-dasharray', '5,5')
                        .attr('opacity', 0.8);
                }

                // Add bars for each metric
                parsedMetrics.forEach((parsedMetric, index) => {
                    const metric = parsedMetric.metricName;
                    
                    // Filter out zero values for this specific metric if skipzero is enabled
                    let metricData = chartData;
                    if (this.config.skipzero) {
                        metricData = chartData.filter(d => {
                            const value = this.getMetricValue(d, metric);
                            return value !== 0 && value !== null && value !== undefined;
                        });
                    }
                    
                    chartGroup.selectAll(`.bars-${index}`)
                        .data(metricData)
                        .enter()
                        .append('rect')
                        .attr('class', `bar bars-${index}`)
                        .attr('x', d => xScale(d.time))
                        .attr('y', d => yScale(this.getMetricValue(d, metric)))
                        .attr('width', xScale.bandwidth())
                        .attr('height', d => height - yScale(this.getMetricValue(d, metric)))
                        .attr('fill', this.color(index))
                        .attr('opacity', (this.config.dataType === 'diff' || this.config.dataType === 'speed') ? 0.9 : 0.8)
                        .on('mouseover', (event, d) => {
                            this.showTooltip(event, d, metric);
                        })
                        .on('mouseout', () => {
                            this.hideTooltip();
                        });
                });
            }

            createDotsChart(chartGroup, width, height) {
                const metrics = this.config.metrics.split(',').map(m => m.trim());
                const parsedMetrics = this.parseMetrics(metrics);
                
                // Filter data to remove first point when showing differences or speed
                let chartData = (this.config.dataType === 'diff' || this.config.dataType === 'speed') ? this.data.slice(1) : this.data;
                
                // Apply zero value filtering if skipzero is enabled
                if (this.config.skipzero) {
                    chartData = this.filterZeroValues(chartData);
                }
                
                const xScale = d3.scaleTime()
                    .domain(d3.extent(chartData, d => d.time))
                    .range([0, width]);

                // Use appropriate values for Y scale based on data type with 10% padding
                const allValues = chartData.flatMap(d => 
                    metrics.map(m => {
                        if (this.config.dataType === 'diff') return d[`${m}_diff`] || 0;
                        if (this.config.dataType === 'speed') return d[`${m}_speed`] || 0;
                        return d[m] || 0;
                    })
                );
                const minValue = d3.min(allValues);
                const maxValue = d3.max(allValues);
                const dataRange = maxValue - minValue;
                const padding = dataRange * 0.1; // 10% of data variation
                
                const yScale = d3.scaleLinear()
                    .domain([minValue - padding, maxValue + padding])
                    .range([height, 0]);

                // Calculate number of ticks based on chart width
                const xTicks = Math.max(2, Math.min(8, Math.floor(width / 80))); // 2-8 ticks based on width
                const yTicks = Math.max(3, Math.min(6, Math.floor(height / 60))); // 3-6 ticks based on height

                // Add axes
                const xAxis = d3.axisBottom(xScale)
                    .ticks(xTicks)
                    .tickFormat(this.getTimeFormat());
                
                const yAxis = d3.axisLeft(yScale)
                    .tickFormat(d => {
                        if (d >= Math.pow(1024, 3)) return d3.format('.1f')(d / Math.pow(1024, 3)) + 'G';
                        if (d >= Math.pow(1024, 2)) return d3.format('.1f')(d / Math.pow(1024, 2)) + 'M';
                        if (d >= 1024) return d3.format('.1f')(d / 1024) + 'K';
                        return d3.format(',.0f')(d);
                    })
                    .ticks(yTicks);

                chartGroup.append('g')
                    .attr('class', 'axis')
                    .attr('transform', `translate(0, ${height})`)
                    .call(xAxis);

                chartGroup.append('g')
                    .attr('class', 'axis')
                    .call(yAxis);

                // Add grid
                chartGroup.append('g')
                    .attr('class', 'grid')
                    .attr('transform', `translate(0, ${height})`)
                    .call(d3.axisBottom(xScale).tickSize(-height).tickFormat(''));

                chartGroup.append('g')
                    .attr('class', 'grid')
                    .call(d3.axisLeft(yScale).tickSize(-width).tickFormat(''));

                // Add "now" line in forecast mode
                if (this.config.forecast) {
                    const nowTime = new Date();
                    const nowX = xScale(nowTime);
                    
                    chartGroup.append('line')
                        .attr('class', 'now-line')
                        .attr('x1', nowX)
                        .attr('y1', 0)
                        .attr('x2', nowX)
                        .attr('y2', height)
                        .attr('stroke', this.config.nowLineColor || '#ff6b6b')
                        .attr('stroke-width', 2)
                        .attr('stroke-dasharray', '5,5')
                        .attr('opacity', 0.8);
                }

                // Create dots for each metric
                parsedMetrics.forEach((parsedMetric, index) => {
                    const metric = parsedMetric.metricName;
                    
                    // Filter out zero values for this specific metric if skipzero is enabled
                    let metricData = chartData;
                    if (this.config.skipzero) {
                        metricData = chartData.filter(d => {
                            const value = this.getMetricValue(d, metric);
                            return value !== 0 && value !== null && value !== undefined;
                        });
                    }
                    
                    chartGroup.selectAll(`.dots-${index}`)
                        .data(metricData)
                        .enter()
                        .append('circle')
                        .attr('class', `dot dots-${index}`)
                        .attr('cx', d => xScale(d.time))
                        .attr('cy', d => yScale(this.getMetricValue(d, metric)))
                        .attr('r', (this.config.dataType === 'diff' || this.config.dataType === 'speed') ? this.pointSize + 2 : this.pointSize + 1) // Slightly larger dots for better visibility
                        .attr('fill', this.color(index))
                        .attr('stroke', 'white')
                        .attr('stroke-width', 1)
                        .attr('opacity', 0.8)
                        .on('mouseover', (event, d) => {
                            this.showTooltip(event, d, metric);
                        })
                        .on('mouseout', () => {
                            this.hideTooltip();
                        });
                });
            }

            createLegend() {
                const legend = d3.select('#legend');
                legend.html('');

                const metrics = this.config.metrics.split(',').map(m => m.trim());
                const parsedMetrics = this.parseMetrics(metrics);
                
                // Add chart title first - use custom name if provided, otherwise default
                let titleText;
                if (this.config.name) {
                    titleText = this.config.name;
                } else {
                    titleText = this.config.dataType === 'speed' ? '⚡ Speed Chart' : (this.config.dataType === 'diff' ? '📈 Rate Chart' : '📊 Counter Chart');
                }
                const periodText = this.config.period ? ` (${this.config.period})` : '';
                
                legend.append('div')
                    .attr('class', 'legend-item chart-title-bottom')
                    .text(titleText + periodText);
                
                // Add metrics
                parsedMetrics.forEach((parsedMetric, index) => {
                    const metric = parsedMetric.metricName;
                    const legendItem = legend.append('div')
                        .attr('class', 'legend-item');

                    legendItem.append('div')
                        .attr('class', 'legend-color')
                        .style('background-color', this.color(index));

                    let label = this.config.dataType === 'speed' ? `${metric} (Speed)` : (this.config.dataType === 'diff' ? `${metric} (Rate)` : `${metric} (Counter)`);
                    if (this.config.divider) {
                        label += ` ÷${this.config.divider}`;
                    }
                    legendItem.append('span')
                        .text(label);
                });
            }

            showTooltip(event, data, metric) {
                const tooltip = d3.select('#tooltip');
                const formatValue = d3.format(',.0f');
                const formatTime = d3.timeFormat('%Y-%m-%d %H:%M:%S');
                
                // Compute values for tooltip regardless of chart type
                const counterValue = (data[metric] ?? data.counterValue ?? 0);
                const rateValue = (data[`${metric}_diff`] ?? data.rateValue ?? 0);
                const speedValue = (data[`${metric}_speed`] ?? data.speedValue ?? 0);
                
                // Format large numbers with appropriate units (1024-based for traffic data)
                let displayCounter = formatValue(counterValue);
                if (counterValue >= Math.pow(1024, 3)) {
                    displayCounter = d3.format('.2f')(counterValue / Math.pow(1024, 3)) + 'G';
                } else if (counterValue >= Math.pow(1024, 2)) {
                    displayCounter = d3.format('.2f')(counterValue / Math.pow(1024, 2)) + 'M';
                } else if (counterValue >= 1024) {
                    displayCounter = d3.format('.2f')(counterValue / 1024) + 'K';
                }
                
                let displayRate = formatValue(rateValue);
                let displaySpeed = formatValue(speedValue);
                if (rateValue >= Math.pow(1024, 3)) {
                    displayRate = d3.format('.2f')(rateValue / Math.pow(1024, 3)) + 'G';
                } else if (rateValue >= Math.pow(1024, 2)) {
                    displayRate = d3.format('.2f')(rateValue / Math.pow(1024, 2)) + 'M';
                } else if (rateValue >= 1024) {
                    displayRate = d3.format('.2f')(rateValue / 1024) + 'K';
                }
                if (speedValue >= Math.pow(1024, 3)) {
                    displaySpeed = d3.format('.2f')(speedValue / Math.pow(1024, 3)) + 'G';
                } else if (speedValue >= Math.pow(1024, 2)) {
                    displaySpeed = d3.format('.2f')(speedValue / Math.pow(1024, 2)) + 'M';
                } else if (speedValue >= 1024) {
                    displaySpeed = d3.format('.2f')(speedValue / 1024) + 'K';
                }
                
                // Build tooltip header with metric name and data type
                const dataTypeLabel = this.config.dataType === 'speed' ? 'Speed' : 
                                    (this.config.dataType === 'diff' ? 'Rate' : 'Counter');
                let tooltipContent = `<strong>${metric} (${dataTypeLabel})</strong><br>Time: ${formatTime(data.time)}<br>`;
                
                // Add divider info if present
                if (this.config.divider) {
                    tooltipContent += `Divider: ${this.config.divider}<br>`;
                }
                
                // Show values based on current data type
                if (this.config.dataType === 'speed') {
                    tooltipContent += `Speed: ${displaySpeed} (${formatValue(speedValue)})/sec<br>`;
                    if (this.config.divider) {
                        tooltipContent += `Scaled Counter: ${displayCounter} (${formatValue(counterValue)})`;
                    } else {
                        tooltipContent += `Counter: ${displayCounter} (${formatValue(counterValue)})`;
                    }
                } else if (this.config.dataType === 'diff') {
                    tooltipContent += `Rate: ${displayRate} (${formatValue(rateValue)})<br>`;
                    if (this.config.divider) {
                        tooltipContent += `Scaled Counter: ${displayCounter} (${formatValue(counterValue)})`;
                    } else {
                        tooltipContent += `Counter: ${displayCounter} (${formatValue(counterValue)})`;
                    }
                } else {
                    if (this.config.divider) {
                        tooltipContent += `Scaled Counter: ${displayCounter} (${formatValue(counterValue)})`;
                    } else {
                        tooltipContent += `Counter: ${displayCounter} (${formatValue(counterValue)})`;
                    }
                }
                
                tooltip.style('opacity', 1)
                    .html(tooltipContent)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            }

            hideTooltip() {
                d3.select('#tooltip').style('opacity', 0);
            }
        }

        // Initialize the widget when the page loads
        let widget;
        document.addEventListener('DOMContentLoaded', function() {
            widget = new SaymonWidget();
        });

        // Cleanup when page is unloaded
        window.addEventListener('beforeunload', function() {
            if (widget && widget.reloadInterval) {
                clearInterval(widget.reloadInterval);
                console.log('Widget auto-reload stopped');
            }
        });
    </script>
</body>
</html>
