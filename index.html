<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saymon Metrics History</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="index-Qi_VvB8y.css">
    <!-- D3.js CDN for immediate functionality -->
    <script type="module" src="d3.v7.min.js"></script>
    <script>
        // Test if D3.js is loaded
        window.addEventListener('load', function() {
            if (typeof d3 === 'undefined') {
                console.error('D3.js not loaded!');
                document.body.innerHTML = '<div style="padding: 20px; text-align: center; color: red;">Error: D3.js failed to load. Please check your internet connection.</div>';
            } else {
                console.log('D3.js loaded successfully:', d3.version);
            }
        });
    </script>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <h1>ðŸ“Š Saymon Metrics History</h1>
        </header>

        <main class="main-content">
            <div class="chart-container">
                <div id="chart" class="chart"></div>
                <div class="chart-info">
                    <div class="tooltip" id="tooltip"></div>
                    <div class="legend" id="legend"></div>
                </div>
            </div>

            <div class="sidebar">
                <div class="config-panel">
                    <h3>Metrics Configuration</h3>
                    <div class="config-inputs">
                        <div class="input-group">
                            <label for="objectId">Object ID:</label>
                            <input type="text" id="objectId" value="67cb1f1f120ab073c5adb8a2" placeholder="Enter object ID">
                        </div>
                        
                        <div class="input-group">
                            <label for="timeRange">Time Range:</label>
                            <select id="timeRange">
                                <option value="custom">Custom</option>
                                <option value="1h">Last Hour</option>
                                <option value="1d">Last Day</option>
                                <option value="1w">Last Week</option>
                                <option value="1m">Last Month</option>
                            </select>
                        </div>
                        
                        <div class="input-group">
                            <label for="fromTimestamp">From Timestamp (msec):</label>
                            <input type="number" id="fromTimestamp" value="1756497678991" placeholder="From timestamp">
                        </div>
                        
                        <div class="input-group">
                            <label for="toTimestamp">To Timestamp (msec):</label>
                            <input type="number" id="toTimestamp" value="1756592718991" placeholder="To timestamp">
                        </div>
                        
                        <div class="input-group">
                            <label for="downsample">Downsample:</label>
                            <select id="downsample">
                                <option value="5m-avg">5m-avg</option>
                                <option value="1m-avg">1m-avg</option>
                                <option value="10m-avg">10m-avg</option>
                                <option value="15m-avg">15m-avg</option>
                                <option value="30m-avg">30m-avg</option>
                                <option value="1h-avg">1h-avg</option>
                            </select>
                        </div>
                        
                        <div class="input-group">
                            <label for="metrics">Metrics (comma-separated):</label>
                            <input type="text" id="metrics" value="ifHCInOctets,ifHCOutOctets" placeholder="ifHCInOctets,ifHCOutOctets">
                        </div>
                        
                        <div class="input-group">
                            <label for="authToken">Authentication Token:</label>
                            <input type="text" id="authToken" value="285c4fd9-6335-41eb-b516-189eb7482d19" placeholder="Enter auth token">
                        </div>
                        
                        <div class="input-group">
                            <label for="chartType">Chart Type:</label>
                            <select id="chartType">
                                <option value="line">Line Chart</option>
                                <option value="bar">Bar Chart</option>
                                <option value="dots">Dots Chart</option>
                            </select>
                        </div>
                        
                        <div class="input-group">
                            <label for="dataType">Data Type:</label>
                            <select id="dataType">
                                <option value="diff">Rate (Difference)</option>
                                <option value="raw">Raw Counter</option>
                            </select>
                        </div>
                    </div>
                    <button id="loadData" class="btn btn-primary">Load Metrics</button>
                    <button id="testApi" class="btn btn-secondary">Test API Conn</button>
                </div>

                <div class="api-info">
                    <h3>API Endpoint</h3>
                    <div class="api-url" id="apiUrl">
                        <code>https://bccdemo.cpult.ru/node/api/objects/67cb1f1f120ab073c5adb8a2/history?from=1756497678991&to=1756592718991&downsample=5m-avg&metrics%5B%5D=ifHCInOctets&metrics%5B%5D=ifHCOutOctets&auth-token=285c4fd9-6335-41eb-b516-189eb7482d19</code>
                    </div>
                    <div class="cors-notice">
                        <p><strong>Note:</strong> If you encounter CORS errors, you may need to use a CORS proxy or run this application from a server that allows cross-origin requests.</p>
                    </div>
                </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // D3.js is loaded via CDN in index.html
        // import * as d3 from 'd3';

        class SaymonMetricsChart {
            constructor() {
                this.data = [];
                this.currentChartType = 'line';
                this.margin = { top: 40, right: 40, bottom: 60, left: 60 };
                this.width = 800;
                this.height = 500;
                this.color = d3.scaleOrdinal(d3.schemeCategory10);
                this.strokeWidth = 2;
                this.pointSize = 6;
                
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.updateApiUrl();
                this.generateSampleData();
                this.calculateDifferences();
                this.createChart();
            }

            generateSampleData() {
                // Generate sample data for demonstration
                this.data = [];
                const fromTime = parseInt(document.getElementById('fromTimestamp').value);
                const toTime = parseInt(document.getElementById('toTimestamp').value);
                const metrics = document.getElementById('metrics').value.split(',').map(m => m.trim());
                const parsedMetrics = this.parseMetrics(metrics);
                
                const timeStep = (toTime - fromTime) / 50; // 50 data points for more detail
                
                // Generate counter data with realistic network traffic patterns
                let currentValues = {};
                parsedMetrics.forEach((parsedMetric, index) => {
                    const metric = parsedMetric.metricName;
                    currentValues[metric] = Math.random() * 10000 + 1000; // Higher starting values
                });
                
                for (let i = 0; i < 50; i++) {
                    const timestamp = fromTime + (i * timeStep);
                    const dataPoint = {
                        timestamp: timestamp,
                        time: new Date(timestamp)
                    };
                    
                    parsedMetrics.forEach((parsedMetric, index) => {
                        const metric = parsedMetric.metricName;
                        // Simulate realistic network traffic with varying intensity
                        let increment;
                        if (i < 10) {
                            // Low traffic period
                            increment = Math.random() * 100 + 50;
                        } else if (i < 20) {
                            // Medium traffic period
                            increment = Math.random() * 300 + 200;
                        } else if (i < 35) {
                            // High traffic period (peak)
                            increment = Math.random() * 800 + 500;
                        } else if (i < 45) {
                            // Medium traffic period
                            increment = Math.random() * 300 + 200;
                        } else {
                            // Low traffic period
                            increment = Math.random() * 100 + 50;
                        }
                        
                        // Add some random spikes
                        if (Math.random() < 0.1) { // 10% chance of spike
                            increment *= 2;
                        }
                        
                        currentValues[metric] += increment;
                        dataPoint[metric] = currentValues[metric];
                    });
                    
                    this.data.push(dataPoint);
                }
            }

            calculateDifferences() {
                const metrics = document.getElementById('metrics').value.split(',').map(m => m.trim());
                const parsedMetrics = this.parseMetrics(metrics);
                
                // Calculate differences between neighboring values for each metric
                parsedMetrics.forEach(parsedMetric => {
                    const metric = parsedMetric.metricName;
                    for (let i = 1; i < this.data.length; i++) {
                        const currentValue = this.data[i][metric] || 0;
                        const previousValue = this.data[i-1][metric] || 0;
                        const difference = currentValue - previousValue;
                        
                        // Store the difference in a new field
                        this.data[i][`${metric}_diff`] = difference;
                    }
                    
                    // For the first data point, set difference to 0 or null
                    this.data[0][`${metric}_diff`] = 0;
                });
                
                // Remove data points with negative differences
                const originalLength = this.data.length;
                this.data = this.data.filter((point, index) => {
                    const hasNegativeDiff = metrics.some(metric => {
                        const diff = point[`${metric}_diff`];
                        return diff < 0;
                    });
                    
                    if (hasNegativeDiff) {
                        console.log(`Removing data point ${index} due to negative difference`);
                    }
                    
                    return !hasNegativeDiff;
                });
                
                const removedCount = originalLength - this.data.length;
                if (removedCount > 0) {
                    console.log(`Removed ${removedCount} data points with negative differences`);
                }
                
                console.log('Calculated differences for metrics:', metrics);
                
                // Log some sample data to show the difference
                if (this.data.length > 0) {
                    console.log('Sample data comparison:');
                    console.log('First 5 data points:');
                    for (let i = 0; i < Math.min(5, this.data.length); i++) {
                        const point = this.data[i];
                        console.log(`Point ${i}:`, {
                            time: point.time.toLocaleTimeString(),
                            ...metrics.reduce((acc, metric) => {
                                acc[`${metric}_counter`] = point[metric];
                                acc[`${metric}_rate`] = point[`${metric}_diff`];
                                return acc;
                            }, {})
                        });
                    }
                }
            }

            getTimeFormat() {
                // For main chart, use a default format since it doesn't have period parameter
                // This can be enhanced later if needed
                return d3.timeFormat('%m/%d %H:%M');
            }

            setupEventListeners() {
                // Load data button
                d3.select('#loadData').on('click', () => {
                    this.loadMetricsData();
                });

                // Chart type selector
                d3.select('#chartType').on('change', (event) => {
                    this.currentChartType = event.target.value;
                    this.createChart();
                });

                // Data type selector
                d3.select('#dataType').on('change', (event) => {
                    this.createChart();
                });

                // Time range selector
                d3.select('#timeRange').on('change', (event) => {
                    this.updateTimeRange(event.target.value);
                });

                // Update API URL when inputs change
                ['objectId', 'fromTimestamp', 'toTimestamp', 'downsample', 'metrics'].forEach(id => {
                    d3.select(`#${id}`).on('input', () => {
                        this.updateApiUrl();
                    });
                });
            }

            updateTimeRange(range) {
                const now = Date.now();
                let fromTime, toTime = now;

                switch (range) {
                    case '1h':
                        fromTime = now - (60 * 60 * 1000); // 1 hour ago
                        break;
                    case '1d':
                        fromTime = now - (24 * 60 * 60 * 1000); // 1 day ago
                        break;
                    case '1w':
                        fromTime = now - (7 * 24 * 60 * 60 * 1000); // 1 week ago
                        break;
                    case '1m':
                        fromTime = now - (30 * 24 * 60 * 60 * 1000); // 1 month ago
                        break;
                    case 'custom':
                    default:
                        return; // Don't change timestamps for custom
                }

                document.getElementById('fromTimestamp').value = fromTime;
                document.getElementById('toTimestamp').value = toTime;
                this.updateApiUrl();
            }

            updateApiUrl() {
                const objectId = document.getElementById('objectId').value;
                const fromTime = document.getElementById('fromTimestamp').value;
                const toTime = document.getElementById('toTimestamp').value;
                const downsample = document.getElementById('downsample').value;
                const metrics = document.getElementById('metrics').value.split(',').map(m => m.trim());
                
                // Parse metrics to extract object IDs and metric names
                const parsedMetrics = this.parseMetrics(metrics);
                
                // Group metrics by object ID
                const metricsByObject = {};
                parsedMetrics.forEach(metric => {
                    if (!metricsByObject[metric.objectId]) {
                        metricsByObject[metric.objectId] = [];
                    }
                    metricsByObject[metric.objectId].push(metric.metricName);
                });
                
                // Generate API URLs for each object
                const apiUrls = Object.keys(metricsByObject).map(objId => {
                    const objectMetrics = metricsByObject[objId];
                    const metricsParams = objectMetrics.map(metric => `metrics%5B%5D=${encodeURIComponent(metric)}`).join('&');
                    return `/node/api/objects/${objId}/history?from=${fromTime}&to=${toTime}&downsample=${downsample}&${metricsParams}`;
                });
                
                document.getElementById('apiUrl').innerHTML = `<code>${apiUrls.join('<br>')}</code>`;
            }

            parseMetrics(metrics) {
                return metrics.map(metric => {
                    // Check if metric contains object ID in format {{objectId:metricName}}
                    const objectIdMatch = metric.match(/^\{\{([^:]+):(.+)\}\}$/);
                    if (objectIdMatch) {
                        return {
                            objectId: objectIdMatch[1],
                            metricName: objectIdMatch[2],
                            originalMetric: metric
                        };
                    } else {
                        // Use default object ID from input
                        const defaultObjectId = document.getElementById('objectId').value;
                        return {
                            objectId: defaultObjectId,
                            metricName: metric,
                            originalMetric: metric
                        };
                    }
                });
            }

            async loadMetricsData() {
                const fromTime = document.getElementById('fromTimestamp').value;
                const toTime = document.getElementById('toTimestamp').value;
                const downsample = document.getElementById('downsample').value;
                const metrics = document.getElementById('metrics').value.split(',').map(m => m.trim());
                
                if (!fromTime || !toTime || !downsample || metrics.length === 0) {
                    alert('Please fill in all required fields');
                    return;
                }

                try {
                    // Parse metrics to extract object IDs and metric names
                    const parsedMetrics = this.parseMetrics(metrics);
                    
                    // Group metrics by object ID
                    const metricsByObject = {};
                    parsedMetrics.forEach(metric => {
                        if (!metricsByObject[metric.objectId]) {
                            metricsByObject[metric.objectId] = [];
                        }
                        metricsByObject[metric.objectId].push(metric.metricName);
                    });
                    
                    console.log('Loading data from multiple objects:', metricsByObject);
                    
                    // For now, generate sample data. Replace with actual API calls:
                    // const allData = [];
                    // for (const [objectId, objectMetrics] of Object.entries(metricsByObject)) {
                    //     const metricsParams = objectMetrics.map(metric => `metrics%5B%5D=${encodeURIComponent(metric)}`).join('&');
                    //     const apiUrl = `/node/api/objects/${objectId}/history?from=${fromTime}&to=${toTime}&downsample=${downsample}&${metricsParams}`;
                    //     const response = await fetch(apiUrl);
                    //     const objectData = await response.json();
                    //     allData.push(...objectData);
                    // }
                    // this.data = this.transformApiData(allData);
                    
                    this.generateSampleData();
                    this.calculateDifferences();
                    this.createChart();
                } catch (error) {
                    console.error('Error loading metrics data:', error);
                    alert('Error loading metrics data. Check console for details.');
                }
            }

            createChart() {
                const chartContainer = d3.select('#chart');
                chartContainer.html('');

                const svg = chartContainer
                    .append('svg')
                    .attr('width', this.width)
                    .attr('height', this.height)
                    .attr('viewBox', `0 0 ${this.width} ${this.height}`);

                const chartGroup = svg.append('g')
                    .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`);

                const chartWidth = this.width - this.margin.left - this.margin.right;
                const chartHeight = this.height - this.margin.top - this.margin.bottom;

                switch (this.currentChartType) {
                    case 'line':
                        this.createLineChart(chartGroup, chartWidth, chartHeight);
                        break;
                    case 'bar':
                        this.createBarChart(chartGroup, chartWidth, chartHeight);
                        break;
                    case 'dots':
                        this.createDotsChart(chartGroup, chartWidth, chartHeight);
                        break;
                }

                this.createLegend();
            }

            createLineChart(chartGroup, width, height) {
                const metrics = document.getElementById('metrics').value.split(',').map(m => m.trim());
                const parsedMetrics = this.parseMetrics(metrics);
                const dataType = document.getElementById('dataType').value;
                
                // Filter data to remove first point when showing differences
                const chartData = dataType === 'diff' ? this.data.slice(1) : this.data;
                
                const xScale = d3.scaleTime()
                    .domain(d3.extent(chartData, d => d.time))
                    .range([0, width]);

                // Use appropriate values for Y scale based on data type with 10% padding
                const allValues = chartData.flatMap(d => 
                    metrics.map(m => dataType === 'diff' ? (d[`${m}_diff`] || 0) : (d[m] || 0))
                );
                const minValue = d3.min(allValues);
                const maxValue = d3.max(allValues);
                const dataRange = maxValue - minValue;
                const padding = dataRange * 0.1; // 10% of data variation
                
                const yScale = d3.scaleLinear()
                    .domain([minValue - padding, maxValue + padding])
                    .range([height, 0]);

                // Add chart title to show current data type
                chartGroup.append('text')
                    .attr('x', width / 2)
                    .attr('y', -10)
                    .attr('text-anchor', 'middle')
                    .attr('class', 'chart-title')
                    .style('font-size', '14px')
                    .style('font-weight', 'bold')
                    .style('fill', dataType === 'diff' ? '#e74c3c' : '#2ecc71')
                    .text(dataType === 'diff' ? 'ðŸ“ˆ Rate Chart (Differences)' : 'ðŸ“Š Counter Chart (Raw Values)');

                // Add axes
                const xAxis = d3.axisBottom(xScale)
                    .tickFormat(this.getTimeFormat());
                const yAxis = d3.axisLeft(yScale);

                chartGroup.append('g')
                    .attr('class', 'axis')
                    .attr('transform', `translate(0, ${height})`)
                    .call(xAxis);

                chartGroup.append('g')
                    .attr('class', 'axis')
                    .call(yAxis);

                // Add grid
                chartGroup.append('g')
                    .attr('class', 'grid')
                    .attr('transform', `translate(0, ${height})`)
                    .call(d3.axisBottom(xScale).tickSize(-height).tickFormat(''));

                chartGroup.append('g')
                    .attr('class', 'grid')
                    .call(d3.axisLeft(yScale).tickSize(-width).tickFormat(''));

                // Create lines for each metric using appropriate values
                parsedMetrics.forEach((parsedMetric, index) => {
                    const metric = parsedMetric.metricName;
                    const line = d3.line()
                        .x(d => xScale(d.time))
                        .y(d => yScale(dataType === 'diff' ? (d[`${metric}_diff`] || 0) : (d[metric] || 0)))
                        .curve(d3.curveLinear);

                    // Add line path with different stroke width for rate vs counter
                    chartGroup.append('path')
                        .datum(chartData)
                        .attr('class', 'line-path')
                        .attr('fill', 'none')
                        .attr('stroke', this.color(index))
                        .attr('stroke-width', dataType === 'diff' ? this.strokeWidth + 1 : this.strokeWidth)
                        .attr('d', line);

                    // Add data points
                    chartGroup.selectAll(`.data-point-${index}`)
                        .data(chartData)
                        .enter()
                        .append('circle')
                        .attr('class', `data-point data-point-${index}`)
                        .attr('cx', d => xScale(d.time))
                        .attr('cy', d => yScale(dataType === 'diff' ? (d[`${metric}_diff`] || 0) : (d[metric] || 0)))
                        .attr('r', dataType === 'diff' ? this.pointSize + 1 : this.pointSize)
                        .attr('fill', this.color(index))
                        .attr('stroke', 'white')
                        .attr('stroke-width', 2)
                        .on('mouseover', (event, d) => this.showTooltip(event, d, metric))
                        .on('mouseout', () => this.hideTooltip());
                });
            }

            createBarChart(chartGroup, width, height) {
                const metrics = document.getElementById('metrics').value.split(',').map(m => m.trim());
                const parsedMetrics = this.parseMetrics(metrics);
                const dataType = document.getElementById('dataType').value;
                
                // Filter data to remove first point when showing differences
                const chartData = dataType === 'diff' ? this.data.slice(1) : this.data;
                
                const xScale = d3.scaleBand()
                    .domain(chartData.map((d, i) => i))
                    .range([0, width])
                    .padding(0.1);

                // Use appropriate values for Y scale based on data type with 10% padding
                const allValues = chartData.flatMap(d => 
                    metrics.map(m => dataType === 'diff' ? (d[`${m}_diff`] || 0) : (d[m] || 0))
                );
                const minValue = d3.min(allValues);
                const maxValue = d3.max(allValues);
                const dataRange = maxValue - minValue;
                const padding = dataRange * 0.1; // 10% of data variation
                
                const yScale = d3.scaleLinear()
                    .domain([minValue - padding, maxValue + padding])
                    .range([height, 0]);

                // Add chart title to show current data type
                chartGroup.append('text')
                    .attr('x', width / 2)
                    .attr('y', -10)
                    .attr('text-anchor', 'middle')
                    .attr('class', 'chart-title')
                    .style('font-size', '14px')
                    .style('font-weight', 'bold')
                    .style('fill', dataType === 'diff' ? '#e74c3c' : '#2ecc71')
                    .text(dataType === 'diff' ? 'ðŸ“Š Rate Chart (Differences)' : 'ðŸ“ˆ Counter Chart (Raw Values)');

                // Add axes
                const xAxis = d3.axisBottom(xScale);
                const yAxis = d3.axisLeft(yScale);

                chartGroup.append('g')
                    .attr('class', 'axis')
                    .attr('transform', `translate(0, ${height})`)
                    .call(xAxis);

                chartGroup.append('g')
                    .attr('class', 'axis')
                    .call(yAxis);

                // Add grid
                chartGroup.append('g')
                    .attr('class', 'grid')
                    .call(d3.axisLeft(yScale).tickSize(-width).tickFormat(''));

                // Add bars for each metric using appropriate values
                parsedMetrics.forEach((parsedMetric, metricIndex) => {
                    const metric = parsedMetric.metricName;
                    chartGroup.selectAll(`.bar-${metricIndex}`)
                        .data(chartData)
                        .enter()
                        .append('rect')
                        .attr('class', `bar bar-${metricIndex}`)
                        .attr('x', (d, i) => xScale(i) + (xScale.bandwidth() / metrics.length) * metricIndex)
                        .attr('y', d => yScale(dataType === 'diff' ? (d[`${metric}_diff`] || 0) : (d[metric] || 0)))
                        .attr('width', xScale.bandwidth() / metrics.length)
                        .attr('height', d => height - yScale(dataType === 'diff' ? (d[`${metric}_diff`] || 0) : (d[metric] || 0)))
                        .attr('fill', this.color(metricIndex))
                        .style('opacity', dataType === 'diff' ? 0.8 : 0.6)
                        .on('mouseover', (event, d) => this.showTooltip(event, d, metric))
                        .on('mouseout', () => this.hideTooltip());
                });
            }

            createDotsChart(chartGroup, width, height) {
                const metrics = document.getElementById('metrics').value.split(',').map(m => m.trim());
                const parsedMetrics = this.parseMetrics(metrics);
                
                const xScale = d3.scaleTime()
                    .domain(d3.extent(this.data, d => d.time))
                    .range([0, width]);

                const yScale = d3.scaleLinear()
                    .domain([0, d3.max(this.data, d => Math.max(...metrics.map(m => d[m] || 0)))])
                    .range([height, 0]);

                // Add axes
                const xAxis = d3.axisBottom(xScale);
                const yAxis = d3.axisLeft(yScale);

                chartGroup.append('g')
                    .attr('class', 'axis')
                    .attr('transform', `translate(0, ${height})`)
                    .call(xAxis);

                chartGroup.append('g')
                    .attr('class', 'axis')
                    .call(yAxis);

                // Add grid
                chartGroup.append('g')
                    .attr('class', 'grid')
                    .attr('transform', `translate(0, ${height})`)
                    .call(d3.axisBottom(xScale).tickSize(-height).tickFormat(''));

                chartGroup.append('g')
                    .attr('class', 'grid')
                    .call(d3.axisLeft(yScale).tickSize(-width).tickFormat(''));

                // Create dots for each metric
                parsedMetrics.forEach((parsedMetric, index) => {
                    const metric = parsedMetric.metricName;
                    chartGroup.selectAll(`.dot-${index}`)
                        .data(this.data)
                        .enter()
                        .append('circle')
                        .attr('class', `dot dot-${index}`)
                        .attr('cx', d => xScale(d.time))
                        .attr('cy', d => yScale(d[metric] || 0))
                        .attr('r', this.pointSize + 2) // Slightly larger dots for better visibility
                        .attr('fill', this.color(index))
                        .attr('stroke', 'white')
                        .attr('stroke-width', 2)
                        .attr('opacity', 0.8)
                        .on('mouseover', (event, d) => this.showTooltip(event, d, metric))
                        .on('mouseout', () => this.hideTooltip());
                });
            }

            showTooltip(event, data, metric) {
                const tooltip = d3.select('#tooltip');
                const counterValue = data[metric] || 0;
                const diffValue = data[`${metric}_diff`] || 0;
                
                tooltip
                    .style('opacity', 1)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px')
                    .html(`
                        <strong>${metric}</strong><br>
                        Time: ${data.time.toLocaleString()}<br>
                        Counter: ${counterValue.toFixed(2)}<br>
                        Rate: ${diffValue.toFixed(2)}
                    `);
            }

            hideTooltip() {
                d3.select('#tooltip').style('opacity', 0);
            }

            createLegend() {
                const legend = d3.select('#legend');
                legend.html('');

                const metrics = document.getElementById('metrics').value.split(',').map(m => m.trim());
                const parsedMetrics = this.parseMetrics(metrics);
                const dataType = document.getElementById('dataType').value;
                
                parsedMetrics.forEach((parsedMetric, index) => {
                    const metric = parsedMetric.metricName;
                    const label = dataType === 'diff' ? `${metric} (Rate)` : `${metric} (Counter)`;
                    legend.append('div')
                        .attr('class', 'legend-item')
                        .html(`
                            <div class="legend-color" style="background-color: ${this.color(index)}"></div>
                            <span>${label}</span>
                        `);
                });
            }
        }

        // Initialize the chart when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM Content Loaded');
            try {
                new SaymonMetricsChart();
            } catch (error) {
                console.error('Error initializing chart:', error);
                // Fallback initialization
                setTimeout(() => {
                    try {
                        console.log('Retrying chart initialization...');
                        new SaymonMetricsChart();
                    } catch (retryError) {
                        console.error('Retry failed:', retryError);
                    }
                }, 1000);
            }
        });

        // Additional fallback for when DOMContentLoaded might have already fired
        if (document.readyState === 'loading') {
            // Document still loading
            console.log('Document still loading, waiting for DOMContentLoaded');
        } else {
            // Document already loaded
            console.log('Document already loaded, initializing immediately');
            try {
                new SaymonMetricsChart();
            } catch (error) {
                console.error('Immediate initialization failed:', error);
            }
        }
    </script>
</body>
</html>
